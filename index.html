<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ExpTech DPIP Lite</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Google+Sans:wght@400;500;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,1,0" />

    <style>
        :root {
            --md-sys-color-primary: #00668A;
            --md-sys-color-surface: #F0F2F5;
            --md-sys-color-surface-container: #FFFFFF;
            --md-sys-color-surface-container-high: #F5F7FA;
            --md-sys-color-on-surface: #101212;
            --md-sys-color-on-surface-variant: #444746;
            --md-sys-color-outline: #747775;
            --md-sys-color-error: #BA1A1A;
            --md-sys-color-safe: #146c2e;
            --shadow-2: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.06);
            --resizer-height: 24px;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body { 
            margin: 0; 
            background: var(--md-sys-color-surface); 
            color: var(--md-sys-color-on-surface); 
            font-family: 'Google Sans', 'Roboto', sans-serif; 
            height: 100dvh; 
            width: 100vw; 
            overflow: hidden; 
            display: flex;
        }

        #app-layout { display: flex; flex-direction: row; width: 100%; height: 100%; padding: 16px; gap: 16px; }

        /* LEFT COLUMN */
        #left-col-wrapper { width: 380px; min-width: 320px; height: 100%; display: flex; flex-direction: column; gap: 12px; z-index: 20; }

        /* HEADER */
        .header-section { display: flex; justify-content: space-between; align-items: center; padding: 4px; flex-shrink: 0; background: var(--md-sys-color-surface); }
        .app-branding { display: flex; align-items: center; gap: 12px; }
        .app-title { font-weight: 700; font-size: 1.25rem; color: var(--md-sys-color-primary); letter-spacing: -0.5px; }
        .header-actions { display: flex; align-items: center; gap: 8px; }
        .time-display { font-family: 'JetBrains Mono', monospace; font-size: 0.95rem; font-weight: 700; color: var(--md-sys-color-on-surface-variant); display: flex; gap: 8px; background: var(--md-sys-color-surface-container-high); padding: 6px 12px; border-radius: 12px; }
        .sim-active .time-display { color: #683D00; background: #FFDCBE; } 
        .icon-btn { background: transparent; border: none; color: var(--md-sys-color-on-surface-variant); cursor: pointer; width: 40px; height: 40px; border-radius: 20px; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        .icon-btn:hover { background: rgba(0,0,0,0.05); color: var(--md-sys-color-primary); }

        /* CONTENT */
        #sidebar-content { display: flex; flex-direction: column; gap: 12px; flex: 1; min-height: 0; overflow: hidden; }

        /* MAP */
        #map-container { flex: 1; height: 100%; position: relative; background: #E0E4E7; border-radius: 24px; overflow: hidden; box-shadow: var(--shadow-2); z-index: 1; }
        #map { height: 100%; width: 100%; }
        #mobile-resizer { display: none; }

        /* COMPONENTS */
        .m3-card { background: var(--md-sys-color-surface-container); border-radius: 16px; padding: 16px; box-shadow: var(--shadow-2); display: flex; flex-direction: column; gap: 12px; border: 1px solid rgba(0,0,0,0.08); flex-shrink: 0; }
        .monitor-panel { min-height: 160px; justify-content: center; flex-shrink: 0; }
        .panel-header { font-size: 0.85rem; font-weight: 700; color: var(--md-sys-color-primary); text-transform: uppercase; letter-spacing: 0.5px; }
        
        #monitor-idle { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; gap: 8px; color: var(--md-sys-color-outline); padding: 20px 0; }
        #monitor-idle span.material-symbols-rounded { font-size: 48px; opacity: 0.5; }
        #monitor-idle div { font-weight: 500; font-size: 1rem; }

        #monitor-active { display: none; flex-direction: column; gap: 12px; height: 100%; }
        .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .stat-card { background: var(--md-sys-color-surface-container-high); border-radius: 12px; padding: 12px 16px; display: flex; flex-direction: column; border: 1px solid rgba(0,0,0,0.05); }
        .stat-label { font-size: 0.75rem; color: var(--md-sys-color-on-surface-variant); font-weight: 600; margin-bottom: 4px; }
        .stat-value { font-family: 'JetBrains Mono', monospace; font-size: 1.5rem; font-weight: 700; color: var(--md-sys-color-on-surface); }
        .stat-unit { font-size: 0.8rem; color: var(--md-sys-color-on-surface-variant); margin-left: 4px; }
        .value-group { display: flex; align-items: baseline; }

        .list-panel { flex: 1; min-height: 0; padding: 0; display: flex; flex-direction: column; overflow: hidden; }
        .list-header { padding: 16px; border-bottom: 1px solid rgba(0,0,0,0.08); font-weight: 700; color: var(--md-sys-color-outline); font-size: 0.8rem; text-transform: uppercase; background: var(--md-sys-color-surface-container); flex-shrink: 0; }
        #quake-list { flex: 1; overflow-y: auto; }
        
        .quake-item { display: flex; align-items: center; gap: 16px; padding: 12px 16px; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .quake-item.active { background: #E1F5FE; border-left: 4px solid var(--md-sys-color-primary); padding-left: 12px; }
        .mag-badge { width: 40px; height: 40px; min-width: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 1rem; color: #1f1f1f; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
        .quake-info h4 { margin: 0; font-size: 0.95rem; font-weight: 600; color: var(--md-sys-color-on-surface); line-height: 1.4; }
        .quake-info p { margin: 0; font-size: 0.8rem; color: var(--md-sys-color-on-surface-variant); }

        /* Toggle & Switch */
        .layer-control { padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.05); display: flex; justify-content: space-between; align-items: center; }
        .layer-label { font-size: 0.9rem; display: flex; align-items: center; gap: 8px; color: var(--md-sys-color-on-surface); font-weight: 500; }
        
        .m3-switch { position: relative; width: 40px; height: 20px; }
        .m3-switch input { opacity: 0; width: 0; height: 0; }
        .m3-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--md-sys-color-outline); border-radius: 24px; transition: .3s; }
        .m3-slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: .3s; }
        
        input:checked + .m3-slider { background-color: var(--md-sys-color-primary); }
        input:checked + .m3-slider:before { transform: translateX(20px); }
        
        /* Disabled Switch Style */
        input:disabled + .m3-slider { background-color: #E0E0E0; cursor: not-allowed; border: 1px solid #ccc; }
        input:disabled + .m3-slider:before { background-color: #BDBDBD; }
        input:checked:disabled + .m3-slider { background-color: #CFD8DC; }

        /* Markers & Banner */
        .user-dot-container { width: 20px; height: 20px; position: relative; }
        .user-dot-core { width: 16px; height: 16px; background-color: #4285F4; border: 2px solid #ffffff; border-radius: 50%; box-shadow: 0 1px 4px rgba(0,0,0,0.3); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2; }
        .user-dot-halo { width: 40px; height: 40px; background-color: rgba(66, 133, 244, 0.2); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); animation: pulse-halo 2s infinite; z-index: 1; }
        @keyframes pulse-halo { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { opacity: 0.5; } 100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; } }
        
        .leaflet-div-icon { background: transparent !important; border: none !important; }
        .int-map-marker { width: 24px !important; height: 24px !important; display: flex; justify-content: center; align-items: center; border-radius: 50%; color: #000; font-weight: 700; font-family: 'JetBrains Mono', monospace; border: 2px solid #fff; font-size: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .int-1 { background: #9fa8da; color: #000; }
        .int-2 { background: #1976d2; color: #fff; border-color: #fff; }
        .int-3 { background: #388e3c; color: #fff; border-color: #fff; }
        .int-4 { background: #fbc02d; color: #000; }
        .int-5-, .int-5\+ { background: #f57c00; color: #fff; border-color: #fff; }
        .int-6-, .int-6\+ { background: #d32f2f; color: #fff; border-color: #fff; }
        .int-7 { background: #4a148c; color: #fff; border-color: #fff; }

        .banner { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 50px; font-weight: 500; font-size: 1rem; box-shadow: var(--shadow-2); display: none; z-index: 2000; text-align: center; align-items: center; gap: 8px; background: var(--md-sys-color-error); color: white; white-space: nowrap; }

        @media (max-width: 900px) {
            #app-layout { flex-direction: column; padding: 0; gap: 0; }
            #left-col-wrapper { display: contents; }
            .header-section { order: 1; width: 100%; height: 56px; border-bottom: 1px solid rgba(0,0,0,0.05); z-index: 100; padding: 0 16px; }
            
            #map-container { order: 2; width: 100%; height: 40%; flex: none; border-radius: 0; margin: 0; }
            .banner { top: 16px; }
            
            #mobile-resizer { display: flex; order: 3; height: var(--resizer-height); width: 100%; background: var(--md-sys-color-surface); align-items: center; justify-content: center; cursor: row-resize; z-index: 50; touch-action: none; border-radius: 16px 16px 0 0; margin-top: -12px; box-shadow: 0 -2px 4px rgba(0,0,0,0.05); }
            .resizer-pill { width: 40px; height: 4px; background: #E0E0E0; border-radius: 2px; }
            
            #sidebar-content { order: 4; width: 100%; flex: 1; min-height: 0; padding: 0 16px 16px 16px; overflow-y: auto; }
            .m3-card { box-shadow: none; border: none; padding: 0; background: transparent; }
            .monitor-panel { border-bottom: 1px solid rgba(0,0,0,0.05); padding-bottom: 12px; margin-bottom: 0; min-height: auto; }
            .list-panel { overflow: visible; }
            #quake-list { overflow: visible; }
            .list-header { display: none; }
        }
    </style>
</head>
<body>

    <div id="app-layout">
        <div id="left-col-wrapper">
            <div class="header-section">
                <div class="app-branding">
                    <div class="app-title">ExpTech DPIP Lite</div>
                </div>
                <div class="header-actions">
                    <div class="time-display" id="clock">
                        <span id="clock-time">--:--</span>
                        <span id="clock-offset" style="font-size:0.8rem; font-weight:500; opacity:0.8; align-self:center;"></span>
                    </div>
                    <button class="icon-btn" onclick="getUserLocation()" title="定位">
                        <span class="material-symbols-rounded">my_location</span>
                    </button>
                </div>
            </div>

            <div id="sidebar-content">
                <div class="m3-card monitor-panel">
                    <div class="panel-header">
                        <span id="monitor-title">即時監測</span>
                    </div>
                    
                    <div id="monitor-idle">
                        <span class="material-symbols-rounded">check_circle</span>
                        <div>目前無地震</div>
                    </div>

                    <div id="monitor-active">
                        <div class="stat-grid">
                            <div class="stat-card">
                                <div class="stat-label">預估震度</div>
                                <div class="value-group">
                                    <div class="stat-value" id="est-local-int" style="color:var(--md-sys-color-primary)">--</div>
                                    <div class="stat-unit">級</div>
                                </div>
                            </div>
                            <div class="stat-card" id="s-wave-card">
                                <div class="stat-label">S波抵達</div>
                                <div class="value-group">
                                    <div class="stat-value" id="s-wave-countdown">--</div>
                                    <div class="stat-unit" id="s-wave-unit">秒</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="layer-control">
                        <div class="layer-label">
                            <span class="material-symbols-rounded" style="color:var(--md-sys-color-safe); font-size:18px;">circle</span>
                            即時震動 (RTS)
                        </div>
                        <label class="m3-switch">
                            <input type="checkbox" checked onchange="toggleLayer('rts')" id="switch-rts">
                            <span class="m3-slider"></span>
                        </label>
                    </div>
                </div>

                <div class="m3-card list-panel">
                    <div class="list-header">歷史地震</div>
                    <div id="quake-list">
                        <div style="padding:20px; text-align:center; color:#777;">載入中...</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="mobile-resizer">
            <div class="resizer-pill"></div>
        </div>

        <div id="map-container">
            <div id="eew-banner" class="banner">
                <span class="material-symbols-rounded">warning</span>
                <span id="banner-text">地震速報</span>
            </div>
            <div id="map"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const mapContainer = document.getElementById('map-container');
        const resizer = document.getElementById('mobile-resizer');
        let isResizing = false;
        
        // FLAG: Tracks if the user is currently panning or zooming
        let isMapInteracting = false;

        resizer.addEventListener('touchstart', (e) => {
            isResizing = true;
            document.body.style.cursor = 'row-resize';
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (!isResizing) return;
            e.preventDefault();
            const touchY = e.touches[0].clientY;
            const headerOffset = 56; 
            const totalHeight = window.innerHeight - headerOffset;
            const relativeY = touchY - headerOffset;

            let newHeightPerc = (relativeY / totalHeight) * 100;
            if (newHeightPerc < 0) newHeightPerc = 0;
            if (newHeightPerc > 80) newHeightPerc = 80;

            mapContainer.style.height = `${newHeightPerc}%`;
            if(map) map.invalidateSize();
        }, { passive: false });

        document.addEventListener('touchend', () => {
            isResizing = false;
            document.body.style.cursor = 'default';
        });

        const Calc = {
            getDistance: (lat1, lon1, lat2, lon2) => {
                const R = 6371e3; const φ1 = lat1 * Math.PI/180; const φ2 = lat2 * Math.PI/180;
                const Δφ = (lat2-lat1) * Math.PI/180; const Δλ = (lon2-lon1) * Math.PI/180;
                const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            },
            pgaToFloat: (pga) => 2 * (Math.log10(pga)) + 0.7,
            intensityFloatToInt: (val) => {
                if (val < 0.5) return "0"; if (val < 1.5) return "1"; if (val < 2.5) return "2";
                if (val < 3.5) return "3"; if (val < 4.5) return "4"; if (val < 5.0) return "5-";
                if (val < 5.5) return "5+"; if (val < 6.0) return "6-"; if (val < 6.5) return "6+"; return "7";
            },
            pgaToIntensity: (pga) => Calc.intensityFloatToInt(Calc.pgaToFloat(pga)),
            estimatePga: (mag, depth, distKm) => {
                const hypoDist = Math.sqrt(Math.pow(distKm, 2) + Math.pow(depth, 2));
                return 1.657 * Math.exp(1.533 * mag) * Math.pow(hypoDist, -1.607);
            }
        };

        const CONFIG = {
            center: [23.8, 121], zoom: 7, 
            // 預設位置為台北 101
            userLoc: { lat: 25.0336, lon: 121.5644, name: "預設: 台北101" },
            reportLimit: 100 
        };

        const PROXIES = [ "https://api.allorigins.win/raw?url=", "https://corsproxy.io/?", "https://thingproxy.freeboard.io/fetch/" ];
        const Routes = {
            station: "https://api-1.exptech.dev/api/v1/trem/station",
            rts: "https://lb-1.exptech.dev/api/v2/trem/rts",
            eew: "https://lb-1.exptech.dev/api/v2/eq/eew",
            reportList: `https://api-1.exptech.dev/api/v2/eq/report?limit=${CONFIG.reportLimit}&page=1`,
            reportDetail: (id) => `https://api-1.exptech.dev/api/v2/eq/report/${id}`,
            locationData: "./location.json"
        };

        let map, layers = {}, stationsCache = null, activeReportId = null;
        let simMode = false, simStartTime = 0, waveTimer = null;
        let pCircle = null, sCircle = null;
        let savedLayerState = { rts: true }; 
        let isRtsEnabled = true;
        let LOCATION_DATA = null;
        let rtsMarkerCache = {}; // Cache for persistent RTS markers
        
        async function fetchJson(url, useProxy = true) {
            if (!useProxy) { try { const res = await fetch(url); if (res.ok) return await res.json(); } catch(e) {} }
            if (useProxy) {
                for (const proxy of PROXIES) { try { const res = await fetch(proxy + encodeURIComponent(url)); if (res.ok) return await res.json(); } catch (e) {} }
            }
            return { error: true };
        }

        async function init() {
            if(!map) initMap();
            window.toggleLayer = toggleLayer;
            window.getUserLocation = getUserLocation;
            
            startNormalClock();
            updateUserMarker();
            
            // 啟動自動定位
            startAutoLocation();
            
            await loadLocationData();
            await loadStations();
            loadReports(); 
            loadRts();
            
            setInterval(loadRts, 1000);
            setInterval(pollEew, 1000);
        }

        async function loadLocationData() {
            const data = await fetchJson(Routes.locationData, false);
            if (!data.error) {
                LOCATION_DATA = data;
                console.log("Location data loaded.");
            }
        }

        function initMap() {
            // preferCanvas: true is crucial for circleMarker performance
            map = L.map('map', { 
                zoomControl: false, 
                attributionControl: false, 
                preferCanvas: true  
            }).setView(CONFIG.center, CONFIG.zoom);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { 
                maxZoom: 19, subdomains: 'abcd',
                attribution: '&copy; OpenStreetMap'
            }).addTo(map);
            
            // Custom Panes setup
            map.createPane('reportPane'); map.getPane('reportPane').style.zIndex = 400; 
            map.createPane('stationPane'); map.getPane('stationPane').style.zIndex = 650; 
            map.createPane('rtsPane'); map.getPane('rtsPane').style.zIndex = 700; 
            map.createPane('labelPane'); map.getPane('labelPane').style.zIndex = 750; 
            map.createPane('userPane'); map.getPane('userPane').style.zIndex = 800;
            
            // Fix: Force Popup pane to be higher than custom panes
            map.getPane('popupPane').style.zIndex = 2000;
            map.getPane('tooltipPane').style.zIndex = 2100;

            layers = {
                activeReport: L.layerGroup().addTo(map),
                rts_dots: L.layerGroup().addTo(map),
                rts_labels: L.layerGroup().addTo(map),
                report_dots: L.layerGroup().addTo(map),
                report_labels: L.layerGroup().addTo(map),
                user: L.layerGroup().addTo(map)
            };

            const onInteractionStart = () => { 
                isMapInteracting = true; 
                if (map.hasLayer(layers.rts_labels)) map.removeLayer(layers.rts_labels);
                if (map.hasLayer(layers.report_labels)) map.removeLayer(layers.report_labels);
            };
            
            const onInteractionEnd = () => { 
                isMapInteracting = false; 
                if (isRtsEnabled && !simMode) {
                    if (!map.hasLayer(layers.rts_labels)) map.addLayer(layers.rts_labels);
                    loadRts(); 
                }
                if (simMode) {
                    if (!map.hasLayer(layers.report_labels)) map.addLayer(layers.report_labels);
                }
            };

            map.on('movestart zoomstart', onInteractionStart);
            map.on('moveend zoomend', onInteractionEnd);
        }

        function toggleLayer(name) {
            if (name === 'rts') {
                isRtsEnabled = !isRtsEnabled;
                if(isRtsEnabled) {
                    map.addLayer(layers.rts_dots);
                    map.addLayer(layers.rts_labels);
                    
                    // Reset cache to force redraw
                    rtsMarkerCache = {};
                    layers.rts_dots.clearLayers();
                    layers.rts_labels.clearLayers();
                    loadRts();
                } else {
                    map.removeLayer(layers.rts_dots);
                    map.removeLayer(layers.rts_labels);
                }
            }
        }

        // 自動定位函式 (修正版：不中斷模擬)
        function startAutoLocation() {
            if (!navigator.geolocation) return;
            // watchPosition 會持續監聽位置
            navigator.geolocation.watchPosition(
                (pos) => {
                    CONFIG.userLoc.lat = pos.coords.latitude;
                    CONFIG.userLoc.lon = pos.coords.longitude;
                    CONFIG.userLoc.name = "您的位置";
                    updateUserMarker(); // 只更新地圖上的藍點，不重啟模擬
                },
                (err) => { 
                    console.log("定位獲取中或權限未允許: " + err.message);
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
        }

        // 手動定位函式 (修正版：不中斷模擬)
        function getUserLocation() {
            if (!navigator.geolocation) { alert("瀏覽器不支援定位"); return; }
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    CONFIG.userLoc.lat = pos.coords.latitude;
                    CONFIG.userLoc.lon = pos.coords.longitude;
                    CONFIG.userLoc.name = "您的位置";
                    updateUserMarker();
                },
                (err) => { console.error(err); alert("無法取得定位，將使用預設位置"); }
            );
        }

        function updateUserMarker() {
            layers.user.clearLayers();
            const icon = L.divIcon({
                className: '',
                html: `<div class="user-dot-container"><div class="user-dot-halo"></div><div class="user-dot-core"></div></div>`,
                iconSize: [40, 40], iconAnchor: [20, 20]
            });
            L.marker([CONFIG.userLoc.lat, CONFIG.userLoc.lon], { icon: icon, pane: 'userPane' })
             .bindPopup(CONFIG.userLoc.name)
             .addTo(layers.user);
        }

        async function loadReports() {
            const list = await fetchJson(`${Routes.reportList}&_t=${Date.now()}`, false);
            if (!Array.isArray(list)) { document.getElementById('quake-list').innerHTML = "無法載入"; return; }
            const container = document.getElementById('quake-list');
            container.innerHTML = '';
            list.forEach((eq) => {
                const item = document.createElement('div');
                item.className = 'quake-item';
                item.id = `item-${eq.id}`;
                item.innerHTML = `
                    <div class="mag-badge" style="background:${getMagColor(eq.mag)}">${eq.mag}</div>
                    <div class="quake-info">
                        <h4>${eq.loc || "未知"}</h4>
                        <p>${formatTime(eq.time)} • ${eq.depth}km</p>
                    </div>`;
                item.onclick = () => renderActiveReport(eq.id, item);
                container.appendChild(item);
            });
        }

        async function renderActiveReport(id, domItem) {
            if (activeReportId === id) { stopSimulation(); return; }
            document.querySelectorAll('.quake-item').forEach(el => el.classList.remove('active'));
            if(domItem) domItem.classList.add('active');
            stopSimulation(); 
            startSimulation(id);
        }

        function setMonitorState(active) {
            const idle = document.getElementById('monitor-idle');
            const act = document.getElementById('monitor-active');
            if (active) {
                idle.style.display = 'none';
                act.style.display = 'flex';
            } else {
                idle.style.display = 'flex';
                act.style.display = 'none';
            }
        }

        async function startSimulation(id) {
            activeReportId = id;
            simMode = true;
            document.getElementById('monitor-title').innerText = "情境模擬";
            setMonitorState(true);
            
            const rtsCheckbox = document.getElementById('switch-rts');
            savedLayerState.rts = isRtsEnabled;
            
            map.removeLayer(layers.rts_dots);
            map.removeLayer(layers.rts_labels);
            rtsCheckbox.checked = false;
            rtsCheckbox.disabled = true;

            const detail = await fetchJson(Routes.reportDetail(id), false);
            if(detail.error) { stopSimulation(); return; }

            simStartTime = detail.time;
            let lat = detail.lat, lon = detail.lon;
            if (!lat && detail.epiCenter) { lat = detail.epiCenter.lat; lon = detail.epiCenter.lon; }

            const bounds = [];
            const color = getMagColor(detail.mag); 
            const maxRadius = getEstimatedRadius(detail.mag);
            let distToUserMeters = 0;

            layers.report_dots.clearLayers();
            layers.report_labels.clearLayers();
            layers.activeReport.clearLayers(); 

            if (lat && lon) {
                bounds.push([lat, lon]);
                distToUserMeters = Calc.getDistance(lat, lon, CONFIG.userLoc.lat, CONFIG.userLoc.lon);

                L.circle([lat, lon], { 
                    radius: maxRadius, color: '#555', weight: 1, dashArray: '4, 4',
                    fillColor: color, fillOpacity: 0.1, pane: 'reportPane', interactive: false 
                }).addTo(layers.activeReport);
                
                L.circleMarker([lat, lon], { radius: 8, color: color, fillColor: '#fff', fillOpacity: 1, weight: 3, pane: 'reportPane' }).bindPopup(`<b>震央</b> M${detail.mag}`).addTo(layers.activeReport);
                
                pCircle = L.circle([lat, lon], { radius: 0, color: '#2e7d32', weight: 1, fill: false, pane: 'reportPane' }).addTo(layers.activeReport);
                sCircle = L.circle([lat, lon], { radius: 0, color: '#c62828', weight: 2, fill: false, pane: 'reportPane' }).addTo(layers.activeReport);

                const distKm = distToUserMeters / 1000; 
                const estPga = Calc.estimatePga(detail.mag, detail.depth, distKm);
                const estInt = Calc.pgaToIntensity(estPga);
                document.getElementById('est-local-int').innerText = estInt;
                document.getElementById('est-local-int').style.color = getIntColorText(estInt);
            }

            if (detail.list) {
                for (const [r, rData] of Object.entries(detail.list)) {
                    if (rData.town) {
                        for (const [t, tData] of Object.entries(rData.town)) {
                            if (tData.lat && tData.lon) {
                                const int = String(tData.int || "0"); 
                                const bgCol = getIntColor(int);
                                bounds.push([tData.lat, tData.lon]);
                                
                                L.circleMarker([tData.lat, tData.lon], { 
                                    radius: 5, color: '#fff', weight: 1, 
                                    fillColor: bgCol, fillOpacity: 1, pane: 'stationPane' 
                                }).bindPopup(`${r}${t} ${int}級`).addTo(layers.report_dots);

                                if (parseFloat(int.replace('+', '.5').replace('-', '.5')) >= 1) {
                                    const icon = L.divIcon({ className: 'int-map-marker', html: int, iconSize: [24, 24], iconAnchor: [12, 12] });
                                    icon.options.className += ` int-${int}`;
                                    const zOff = parseInt(int.replace('+','').replace('-','')) * 1000;
                                    L.marker([tData.lat, tData.lon], { icon: icon, pane: 'labelPane', interactive:false, zIndexOffset: zOff }).addTo(layers.report_labels);
                                }
                            }
                        }
                    }
                }
            }
            if (bounds.length > 0) map.fitBounds(bounds, { padding: [50, 50], maxZoom: 10, animate: true });

            const sSpeed = 3500; const pSpeed = 6500;
            const maxDurationSec = (maxRadius / sSpeed) + 10; 
            const startTime = Date.now();

            waveTimer = setInterval(() => {
                const now = Date.now();
                const animElapsed = (now - startTime); 
                const simSeconds = animElapsed / 1000; 
                
                if (simSeconds > maxDurationSec) { stopSimulation(); return; }
                
                if (!isMapInteracting) {
                    if(pCircle) pCircle.setRadius(pSpeed * simSeconds);
                    if(sCircle) sCircle.setRadius(sSpeed * simSeconds);

                    const displaySeconds = Math.floor(simSeconds);
                    const simDate = new Date(simStartTime + (displaySeconds * 1000));
                    
                    document.getElementById('clock-time').innerText = simDate.toLocaleTimeString('zh-TW', {hour12:false});
                    document.getElementById('clock-offset').innerText = `(+${displaySeconds}s)`;
                    
                    if(lat && lon) {
                        const el = document.getElementById('s-wave-countdown');
                        const unit = document.getElementById('s-wave-unit');
                        
                        if (distToUserMeters > maxRadius) {
                            el.innerText = "無影響";
                            el.style.color = '#999';
                            unit.style.display = 'none';
                        } else {
                            const sArrivalSec = distToUserMeters / sSpeed;
                            const timeLeft = Math.max(0, sArrivalSec - simSeconds);
                            
                            unit.style.display = 'inline';
                            if(timeLeft > 0) {
                                el.innerText = timeLeft.toFixed(0);
                                el.style.color = 'var(--md-sys-color-on-surface)';
                            } else {
                                el.innerText = "已抵達";
                                el.style.color = 'var(--md-sys-color-error)';
                                unit.style.display = 'none';
                            }
                        }
                    }
                }
            }, 30);
        }

        function stopSimulation() {
            simMode = false;
            activeReportId = null;
            document.getElementById('monitor-title').innerText = "即時監測";
            setMonitorState(false);
            
            document.getElementById('clock-offset').innerText = ""; 
            document.getElementById('clock-time').textContent = new Date().toLocaleTimeString('zh-TW', {hour12:false}); 
            
            document.querySelectorAll('.quake-item').forEach(el => el.classList.remove('active'));
            layers.activeReport.clearLayers();
            layers.report_dots.clearLayers();
            layers.report_labels.clearLayers();

            if(waveTimer) clearInterval(waveTimer);

            const rtsCheckbox = document.getElementById('switch-rts');
            rtsCheckbox.disabled = false;
            rtsCheckbox.checked = savedLayerState.rts;
            isRtsEnabled = savedLayerState.rts;
            
            if(isRtsEnabled) {
                map.addLayer(layers.rts_dots);
                map.addLayer(layers.rts_labels);
                // Clear cache on stop to ensure clean state
                rtsMarkerCache = {};
                layers.rts_dots.clearLayers();
                layers.rts_labels.clearLayers();
                loadRts();
            }
        }

        async function loadRts() {
            if (simMode || isMapInteracting || !isRtsEnabled) return; 

            const data = await fetchJson(`${Routes.rts}?_t=${Date.now()}`, false);
            if (!data || data.error) return;
            if (isMapInteracting) return; 

            let stations = [];
            for (const [id, valObj] of Object.entries(data.station || {})) {
                if (valObj.pga >= 0.8) {
                    stations.push({ id, ...valObj });
                }
            }
            stations.sort((a, b) => a.pga - b.pga);

            const currentRoundIds = new Set();

            for (const stData of stations) {
                const id = stData.id;
                currentRoundIds.add(id);

                const pga = stData.pga;
                const st = stationsCache ? stationsCache[id] : null;
                let lat, lon;
                if (st) { 
                    if (st.lat) { lat = st.lat; lon = st.lon; } 
                    else if (st.info && st.info[0]) { lat = st.info[0].lat; lon = st.info[0].lon; } 
                }

                if (lat && lon) {
                    const intStr = Calc.pgaToIntensity(pga);
                    const color = getIntColor(intStr);
                    const radius = 5 + (Math.log(pga) * 1.5);
                    
                    // Name Resolution
                    let displayName = id;
                    let code = null;
                    if (st && st.info && st.info.length > 0) code = st.info[st.info.length - 1].code;
                    if (st && st.name) displayName = st.name;
                    else if (code && LOCATION_DATA && LOCATION_DATA[code]) {
                        const loc = LOCATION_DATA[code];
                        if (loc.city && loc.town) displayName = `${loc.city}${loc.cityLevel||''}${loc.town}${loc.townLevel||''}`;
                    }

                    const popupContent = `${displayName}<br>${pga} gal`;

                    if (rtsMarkerCache[id]) {
                        // UPDATE Existing
                        const cached = rtsMarkerCache[id];
                        cached.dot.setLatLng([lat, lon]); 
                        cached.dot.setRadius(radius);
                        cached.dot.setStyle({ fillColor: color });
                        
                        if (cached.dot.getPopup()) {
                            cached.dot.getPopup().setContent(popupContent);
                        } else {
                             cached.dot.bindPopup(popupContent);
                        }

                        const showLabel = (pga >= 2.5);
                        
                        if (showLabel) {
                            if (cached.label) {
                                const oldInt = cached.currentInt;
                                if (oldInt !== intStr) {
                                    const icon = L.divIcon({ className: `int-map-marker int-${intStr}`, html: intStr, iconSize: [24, 24], iconAnchor:[12,12] });
                                    cached.label.setIcon(icon);
                                    cached.currentInt = intStr;
                                }
                                cached.label.setLatLng([lat, lon]);
                                cached.label.setZIndexOffset(parseInt(pga * 100));
                            } else {
                                const icon = L.divIcon({ className: `int-map-marker int-${intStr}`, html: intStr, iconSize: [24, 24], iconAnchor:[12,12] });
                                const labelMarker = L.marker([lat, lon], { icon: icon, pane: 'labelPane', interactive: false, zIndexOffset: parseInt(pga * 100) }).addTo(layers.rts_labels);
                                cached.label = labelMarker;
                                cached.currentInt = intStr;
                            }
                        } else {
                            if (cached.label) {
                                layers.rts_labels.removeLayer(cached.label);
                                cached.label = null;
                            }
                        }

                    } else {
                        // CREATE New
                        const dotMarker = L.circleMarker([lat, lon], { 
                            radius: radius, 
                            color: '#666', weight: 0.5, 
                            fillColor: color, fillOpacity: 0.8, 
                            pane: 'rtsPane' 
                        }).bindPopup(popupContent).addTo(layers.rts_dots);

                        let labelMarker = null;
                        if (pga >= 2.5) {
                            const icon = L.divIcon({ className: `int-map-marker int-${intStr}`, html: intStr, iconSize: [24, 24], iconAnchor:[12,12] });
                            labelMarker = L.marker([lat, lon], { icon: icon, pane: 'labelPane', interactive: false, zIndexOffset: parseInt(pga * 100) }).addTo(layers.rts_labels);
                        }

                        rtsMarkerCache[id] = {
                            dot: dotMarker,
                            label: labelMarker,
                            currentInt: intStr
                        };
                    }
                }
            }

            // Remove vanished stations
            for (const cacheId in rtsMarkerCache) {
                if (!currentRoundIds.has(cacheId)) {
                    const cached = rtsMarkerCache[cacheId];
                    if (cached.dot) layers.rts_dots.removeLayer(cached.dot);
                    if (cached.label) layers.rts_labels.removeLayer(cached.label);
                    delete rtsMarkerCache[cacheId];
                }
            }
        }

        async function pollEew() {
            if(simMode) return; 
            const data = await fetchJson(`${Routes.eew}?_t=${Date.now()}`, false);
            const banner = document.getElementById('eew-banner');
            const bannerText = document.getElementById('banner-text');
            
            if (Array.isArray(data)) {
                // FIXED: 'author' from JSON key
                const cwa = data.find(e => e.author === 'cwa');
                
                // FIXED: 'eq' nested object
                if (cwa && cwa.eq) {
                    const info = cwa.eq;
                    banner.style.display = 'flex';
                    bannerText.innerHTML = `地震速報 (${formatTime(info.time)}) M${info.mag} ${info.loc}`;
                    setMonitorState(true);
                    document.getElementById('est-local-int').innerText = "計算中";
                    document.getElementById('s-wave-countdown').innerText = "計算中";
                    document.getElementById('s-wave-unit').style.display = 'none';
                } else {
                    banner.style.display = 'none';
                    if(!simMode) setMonitorState(false);
                }
            }
        }

        async function loadStations() { const data = await fetchJson(Routes.station, false); if (!data.error) stationsCache = data; }

        function getMagColor(mag) { return mag >= 6 ? '#b3261e' : (mag >= 4 ? '#f57c00' : '#2e7d32'); }
        function getEstimatedRadius(mag) { if (mag < 4) return 20000; if (mag < 5) return 60000; if (mag < 6) return 150000; return 300000; }
        
        function getIntColor(intStr) { 
            const map = { '0':'#e0e0e0', '1':'#9fa8da', '2':'#1976d2', '3':'#388e3c', '4':'#fbc02d', '5-':'#f57c00', '5+':'#e64a19', '6-':'#d32f2f', '6+':'#b71c1c', '7':'#4a148c' }; 
            return map[intStr] || '#ccc'; 
        }
        function getIntColorText(intStr) {
            if(intStr === '0' || intStr === '1') return '#757575';
            return getIntColor(intStr);
        }

        function formatTime(ts) { if(!ts) return ''; return new Date(Number(ts)||ts).toLocaleString('zh-TW', {month:'numeric', day:'numeric', hour:'2-digit', minute:'2-digit'}); }
        
        function startNormalClock() { 
            setInterval(() => { 
                if(!simMode) {
                    document.getElementById('clock-time').textContent = new Date().toLocaleTimeString('zh-TW', {hour12:false}); 
                    document.getElementById('clock-offset').textContent = "";
                }
            }, 1000); 
        }

        init();
    </script>
</body>
</html>
